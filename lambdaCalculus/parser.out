Created by PLY version 3.7 (http://www.dabeaz.com/ply)

Unused terminals:

    IS_ZERO

Grammar

Rule 0     S' -> term
Rule 1     term -> n
Rule 2     term -> BOOL
Rule 3     term -> VAR
Rule 4     term -> IF term THEN term ELSE term
Rule 5     term -> VAR : type . term
Rule 6     type -> TBOOL
Rule 7     type -> TNAT
Rule 8     type -> type TO type
Rule 9     type -> ( type TO type )
Rule 10    n -> NUM
Rule 11    n -> SUC ( term )
Rule 12    n -> PRED ( term )

Terminals, with rules where they appear

(                    : 9 11 12
)                    : 9 11 12
.                    : 5
:                    : 5
BOOL                 : 2
ELSE                 : 4
IF                   : 4
IS_ZERO              : 
NUM                  : 10
PRED                 : 12
SUC                  : 11
TBOOL                : 6
THEN                 : 4
TNAT                 : 7
TO                   : 8 9
VAR                  : 3 5
error                : 

Nonterminals, with rules where they appear

n                    : 1
term                 : 4 4 4 5 11 12 0
type                 : 5 8 8 9 9

Parsing method: LALR

state 0

    (0) S' -> . term
    (1) term -> . n
    (2) term -> . BOOL
    (3) term -> . VAR
    (4) term -> . IF term THEN term ELSE term
    (5) term -> . VAR : type . term
    (10) n -> . NUM
    (11) n -> . SUC ( term )
    (12) n -> . PRED ( term )

    BOOL            shift and go to state 5
    VAR             shift and go to state 7
    IF              shift and go to state 8
    NUM             shift and go to state 4
    SUC             shift and go to state 2
    PRED            shift and go to state 6

    term                           shift and go to state 1
    n                              shift and go to state 3

state 1

    (0) S' -> term .



state 2

    (11) n -> SUC . ( term )

    (               shift and go to state 9


state 3

    (1) term -> n .

    THEN            reduce using rule 1 (term -> n .)
    )               reduce using rule 1 (term -> n .)
    $end            reduce using rule 1 (term -> n .)
    ELSE            reduce using rule 1 (term -> n .)


state 4

    (10) n -> NUM .

    $end            reduce using rule 10 (n -> NUM .)
    )               reduce using rule 10 (n -> NUM .)
    ELSE            reduce using rule 10 (n -> NUM .)
    THEN            reduce using rule 10 (n -> NUM .)


state 5

    (2) term -> BOOL .

    THEN            reduce using rule 2 (term -> BOOL .)
    )               reduce using rule 2 (term -> BOOL .)
    $end            reduce using rule 2 (term -> BOOL .)
    ELSE            reduce using rule 2 (term -> BOOL .)


state 6

    (12) n -> PRED . ( term )

    (               shift and go to state 10


state 7

    (3) term -> VAR .
    (5) term -> VAR . : type . term

    THEN            reduce using rule 3 (term -> VAR .)
    )               reduce using rule 3 (term -> VAR .)
    $end            reduce using rule 3 (term -> VAR .)
    ELSE            reduce using rule 3 (term -> VAR .)
    :               shift and go to state 11


state 8

    (4) term -> IF . term THEN term ELSE term
    (1) term -> . n
    (2) term -> . BOOL
    (3) term -> . VAR
    (4) term -> . IF term THEN term ELSE term
    (5) term -> . VAR : type . term
    (10) n -> . NUM
    (11) n -> . SUC ( term )
    (12) n -> . PRED ( term )

    BOOL            shift and go to state 5
    VAR             shift and go to state 7
    IF              shift and go to state 8
    NUM             shift and go to state 4
    SUC             shift and go to state 2
    PRED            shift and go to state 6

    term                           shift and go to state 12
    n                              shift and go to state 3

state 9

    (11) n -> SUC ( . term )
    (1) term -> . n
    (2) term -> . BOOL
    (3) term -> . VAR
    (4) term -> . IF term THEN term ELSE term
    (5) term -> . VAR : type . term
    (10) n -> . NUM
    (11) n -> . SUC ( term )
    (12) n -> . PRED ( term )

    BOOL            shift and go to state 5
    VAR             shift and go to state 7
    IF              shift and go to state 8
    NUM             shift and go to state 4
    SUC             shift and go to state 2
    PRED            shift and go to state 6

    term                           shift and go to state 13
    n                              shift and go to state 3

state 10

    (12) n -> PRED ( . term )
    (1) term -> . n
    (2) term -> . BOOL
    (3) term -> . VAR
    (4) term -> . IF term THEN term ELSE term
    (5) term -> . VAR : type . term
    (10) n -> . NUM
    (11) n -> . SUC ( term )
    (12) n -> . PRED ( term )

    BOOL            shift and go to state 5
    VAR             shift and go to state 7
    IF              shift and go to state 8
    NUM             shift and go to state 4
    SUC             shift and go to state 2
    PRED            shift and go to state 6

    term                           shift and go to state 14
    n                              shift and go to state 3

state 11

    (5) term -> VAR : . type . term
    (6) type -> . TBOOL
    (7) type -> . TNAT
    (8) type -> . type TO type
    (9) type -> . ( type TO type )

    TBOOL           shift and go to state 17
    TNAT            shift and go to state 16
    (               shift and go to state 15

    type                           shift and go to state 18

state 12

    (4) term -> IF term . THEN term ELSE term

    THEN            shift and go to state 19


state 13

    (11) n -> SUC ( term . )

    )               shift and go to state 20


state 14

    (12) n -> PRED ( term . )

    )               shift and go to state 21


state 15

    (9) type -> ( . type TO type )
    (6) type -> . TBOOL
    (7) type -> . TNAT
    (8) type -> . type TO type
    (9) type -> . ( type TO type )

    TBOOL           shift and go to state 17
    TNAT            shift and go to state 16
    (               shift and go to state 15

    type                           shift and go to state 22

state 16

    (7) type -> TNAT .

    TO              reduce using rule 7 (type -> TNAT .)
    .               reduce using rule 7 (type -> TNAT .)
    )               reduce using rule 7 (type -> TNAT .)


state 17

    (6) type -> TBOOL .

    TO              reduce using rule 6 (type -> TBOOL .)
    .               reduce using rule 6 (type -> TBOOL .)
    )               reduce using rule 6 (type -> TBOOL .)


state 18

    (5) term -> VAR : type . . term
    (8) type -> type . TO type

    .               shift and go to state 23
    TO              shift and go to state 24


state 19

    (4) term -> IF term THEN . term ELSE term
    (1) term -> . n
    (2) term -> . BOOL
    (3) term -> . VAR
    (4) term -> . IF term THEN term ELSE term
    (5) term -> . VAR : type . term
    (10) n -> . NUM
    (11) n -> . SUC ( term )
    (12) n -> . PRED ( term )

    BOOL            shift and go to state 5
    VAR             shift and go to state 7
    IF              shift and go to state 8
    NUM             shift and go to state 4
    SUC             shift and go to state 2
    PRED            shift and go to state 6

    term                           shift and go to state 25
    n                              shift and go to state 3

state 20

    (11) n -> SUC ( term ) .

    $end            reduce using rule 11 (n -> SUC ( term ) .)
    )               reduce using rule 11 (n -> SUC ( term ) .)
    ELSE            reduce using rule 11 (n -> SUC ( term ) .)
    THEN            reduce using rule 11 (n -> SUC ( term ) .)


state 21

    (12) n -> PRED ( term ) .

    $end            reduce using rule 12 (n -> PRED ( term ) .)
    )               reduce using rule 12 (n -> PRED ( term ) .)
    ELSE            reduce using rule 12 (n -> PRED ( term ) .)
    THEN            reduce using rule 12 (n -> PRED ( term ) .)


state 22

    (9) type -> ( type . TO type )
    (8) type -> type . TO type

    TO              shift and go to state 26


state 23

    (5) term -> VAR : type . . term
    (1) term -> . n
    (2) term -> . BOOL
    (3) term -> . VAR
    (4) term -> . IF term THEN term ELSE term
    (5) term -> . VAR : type . term
    (10) n -> . NUM
    (11) n -> . SUC ( term )
    (12) n -> . PRED ( term )

    BOOL            shift and go to state 5
    VAR             shift and go to state 7
    IF              shift and go to state 8
    NUM             shift and go to state 4
    SUC             shift and go to state 2
    PRED            shift and go to state 6

    term                           shift and go to state 27
    n                              shift and go to state 3

state 24

    (8) type -> type TO . type
    (6) type -> . TBOOL
    (7) type -> . TNAT
    (8) type -> . type TO type
    (9) type -> . ( type TO type )

    TBOOL           shift and go to state 17
    TNAT            shift and go to state 16
    (               shift and go to state 15

    type                           shift and go to state 28

state 25

    (4) term -> IF term THEN term . ELSE term

    ELSE            shift and go to state 29


state 26

    (9) type -> ( type TO . type )
    (8) type -> type TO . type
    (6) type -> . TBOOL
    (7) type -> . TNAT
    (8) type -> . type TO type
    (9) type -> . ( type TO type )

    TBOOL           shift and go to state 17
    TNAT            shift and go to state 16
    (               shift and go to state 15

    type                           shift and go to state 30

state 27

    (5) term -> VAR : type . term .

    THEN            reduce using rule 5 (term -> VAR : type . term .)
    )               reduce using rule 5 (term -> VAR : type . term .)
    $end            reduce using rule 5 (term -> VAR : type . term .)
    ELSE            reduce using rule 5 (term -> VAR : type . term .)


state 28

    (8) type -> type TO type .
    (8) type -> type . TO type

  ! shift/reduce conflict for TO resolved as shift
    .               reduce using rule 8 (type -> type TO type .)
    )               reduce using rule 8 (type -> type TO type .)
    TO              shift and go to state 24

  ! TO              [ reduce using rule 8 (type -> type TO type .) ]


state 29

    (4) term -> IF term THEN term ELSE . term
    (1) term -> . n
    (2) term -> . BOOL
    (3) term -> . VAR
    (4) term -> . IF term THEN term ELSE term
    (5) term -> . VAR : type . term
    (10) n -> . NUM
    (11) n -> . SUC ( term )
    (12) n -> . PRED ( term )

    BOOL            shift and go to state 5
    VAR             shift and go to state 7
    IF              shift and go to state 8
    NUM             shift and go to state 4
    SUC             shift and go to state 2
    PRED            shift and go to state 6

    term                           shift and go to state 31
    n                              shift and go to state 3

state 30

    (9) type -> ( type TO type . )
    (8) type -> type TO type .
    (8) type -> type . TO type

  ! shift/reduce conflict for TO resolved as shift
    )               shift and go to state 32
    TO              shift and go to state 24

  ! TO              [ reduce using rule 8 (type -> type TO type .) ]


state 31

    (4) term -> IF term THEN term ELSE term .

    THEN            reduce using rule 4 (term -> IF term THEN term ELSE term .)
    )               reduce using rule 4 (term -> IF term THEN term ELSE term .)
    $end            reduce using rule 4 (term -> IF term THEN term ELSE term .)
    ELSE            reduce using rule 4 (term -> IF term THEN term ELSE term .)


state 32

    (9) type -> ( type TO type ) .

    TO              reduce using rule 9 (type -> ( type TO type ) .)
    .               reduce using rule 9 (type -> ( type TO type ) .)
    )               reduce using rule 9 (type -> ( type TO type ) .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for TO in state 28 resolved as shift
WARNING: shift/reduce conflict for TO in state 30 resolved as shift
